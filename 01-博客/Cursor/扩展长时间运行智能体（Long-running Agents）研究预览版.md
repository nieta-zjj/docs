---
title: "扩展长时间运行智能体（Long-running Agents）研究预览版"
---

## 摘要

### 1) 一句话总结
Cursor 面向 Ultra、Teams 和 Enterprise 用户推出了长时间运行智能体（Long-running Agents）研究预览版，通过定制的运行框架使智能体能够自主规划并执行长达数天的大型复杂编程任务。

### 2) 关键要点
*   **开放范围**：该研究预览版现已在 cursor.com/agents 向所有 Ultra、Teams 和 Enterprise 用户开放。
*   **核心机制**：采用“执行前先规划”（提出计划并等待用户批准）和“多智能体交叉检查”的定制运行框架，以确保智能体贯彻执行复杂任务。
*   **运行表现**：智能体通常运行超过一天，生成的拉取请求（PR）规模庞大（如用户反馈生成了 15.1 万行代码的 PR），且合并率与其他智能体相当，几乎不需要后续修改。
*   **实际应用案例**：成功完成了构建全新聊天平台（36小时）、基于 Web 应用开发移动端（30小时）以及重构身份验证和 RBAC 系统（25小时）等任务。
*   **内部生产验证**：Cursor 内部已将其用于视频渲染器向 Rust 的全面迁移、实现沙盒代码的网络策略控制（生成 1 万行 PR），以及解决 Cursor CLI 中的 Sudo 支持问题。
*   **代码质量提升**：相比同步智能体，长时间运行智能体生成的代码更符合生产要求，能够主动找出边缘情况并创建高覆盖率的测试。
*   **未来规划**：目标是迈向“自动驾驶代码库”，目前正在优化智能体间的协作以支持并行工作流，并开发新工具来处理海量生成的代码。

### 3) 风险与不足（基于原文明确提及）
*   **长周期任务失败风险**：前沿模型在处理长周期任务时经常会出现可预见的失败，如忘记任务的全局目标、迷失方向或半途而废。
*   **错误放大风险**：当智能体自主处理大型任务时，一个微小的错误假设可能会在最终演变成完全错误的解决方案（目前通过前期计划审批来缓解）。
*   **特定操作崩溃问题**：在涉及系统管理或运维的任务中，遇到 `sudo` 权限请求曾会导致 CLI 智能体崩溃。
*   **海量代码部署挑战**：随着智能体生成代码量的激增，目前缺乏足够的新方法和工具来安全地将这些海量代码部署到生产环境中。

## 正文

Cursor 的长时间运行智能体（Long-running agents）研究预览版现已在 cursor.com/agents 向所有 Ultra、Teams 和 Enterprise 用户开放。

长时间运行智能体是我们针对“智能体自主完成更宏大项目”的研究成果，这其中也包括我们上个月分享的“Cursor 如何构建网络浏览器”的实验。

在之前的实验中，我们发现前沿模型在处理长周期任务时，往往会出现可预见的失败。为了突破这些局限，我们开发了一个定制的运行框架（harness），使智能体能够承担更困难的工作并坚持将其完成。

上周，我们作为研究预览版发布了该框架的一个版本。结果显示，长时间运行智能体生成了规模大得多的 PR（拉取请求），且合并率与其他智能体相当。

通过与参与预览版的用户交流，我们了解到长时间运行智能体成功完成了许多以前对智能体来说遥不可及的任务。以下是几个来自研究预览版的运行实例：

*   集成现有开源工具，构建一个全新的聊天平台（运行时间：36小时）
*   基于现有的 Web 应用实现移动端应用（运行时间：30小时）
*   重构身份验证和 RBAC（基于角色的访问控制）系统（运行时间：25小时）

### 提升模型能力

成功完成困难任务需要前沿的智能模型和合适的运行框架。通过与每一个前沿模型合作并为它们构建定制框架，我们能够打造出最佳的脚手架，充分发挥不同模型的优势。我们发现以下几个通用原则有助于实现更好的性能：

**执行前先规划**
在直接与模型交互时，紧凑的提示-响应循环让你可以监控智能体，并在需要时将其拉回正轨。但当智能体自主处理大型任务时，一个微小的错误假设可能会在最终演变成完全错误的解决方案。
因此，Cursor 中的长时间运行智能体会先提出计划并等待批准，然后再开始执行。这种前期的对齐有效减少了后续的返工需求。

**坚持完成任务**
前沿模型能写出优秀的代码，但经常会忘记任务的全局目标、迷失方向或半途而废。
长时间运行智能体通过依赖计划，并让多个不同的智能体互相检查工作，从而确保能够贯彻执行更大、更复杂的任务。

### 迄今为止的发现

研究预览版的首批参与者使用长时间运行智能体实现了大型功能、重构了复杂系统、修复了棘手的 Bug、全面优化了性能，并编写了高覆盖率的测试。

智能体通常会运行超过一天，生成的 PR 几乎不需要后续修改即可合并。用户可以离开电脑、专注于其他工作，回来时就能看到可用的解决方案。以下是部分用户的真实反馈：

*   “我发布了两个架构重构项目。对于那种‘我不知道这是否可行，但我很好奇想看看’的工作来说，这是一个不可思议的工具。我可以同时并行运行五个任务，从创建 Mac 窗口管理器到将 CEF 嵌入 Tauri 无所不包。”
*   “我原本计划花整整一个季度来完成这个项目。有了 Cursor 长时间运行智能体，时间缩短到了短短几天。而且我还能额外做两三个项目。我可以启动一个 52 小时的任务，不需要盯着它，回来就能看到一个包含 15.1 万行代码的大型 PR。”
*   “与同步智能体相比，长时间运行智能体的方法更彻底，编写的代码也更符合生产要求。新框架最神奇的地方在于，它能让同一个模型产出生产级别的代码。我用 Codex 5.3 测试了同一个修复 Bug 的提示词，本地智能体很快就修复了它，但长时间运行智能体走得更远——它找出了边缘情况，修复了类似的问题，并创建了高覆盖率的测试。”

### 在 Cursor 内部使用长时间运行智能体

在过去的一个月里，我们一直在内部测试长时间运行智能体的极限。我们用它进行实验以探索其潜力，也将其用于 Cursor 本身的生产工作。以下是我们交给长时间运行智能体并已成功合并的几个任务：

**视频渲染器优化**
我们要求智能体优化一个性能成为部署瓶颈的视频渲染器。它完全基于原始逻辑，完成了向 Rust 的全面迁移并实现了自定义内核，生成了完全一致的视觉输出。

**沙盒代码的策略驱动网络访问**
我们需要为沙盒进程提供由 JSON 驱动的网络策略控制和本地 HTTP 代理。该代理需要跨协议保持正确性、一致地执行策略，并在安全拦截时不能泄露被阻止的流量。长时间运行智能体创建了一个长达一万行的 PR，在运行大型测试套件时几乎没有发现问题。后续的修改工作主要集中在我们最初请求中未明确说明的变更上。

**Cursor CLI 中的 Sudo 支持**
有些任务（特别是涉及系统管理或运维的任务）一旦遇到 sudo 就会导致 CLI 智能体崩溃。我们要求长时间运行智能体实现安全的 sudo 密码提示，这需要拼接多个子系统并梳理 Unix 身份验证流程。它最终生成了一个有效的实现，目前已被 Cursor CLI 采用。

### 迈向自动驾驶的代码库

Cursor 中的长时间运行智能体是迈向“自动驾驶代码库”（self-driving codebases）的早期里程碑，未来智能体将在更少的人工干预下处理更多工作。现在，你已经可以把大型任务委托给它，几小时或几天后回来验收可用的解决方案。

我们正在努力改善长时间运行智能体之间的协作，以便它们能将大型项目拆分为并行的工作流，在更少的人工干预下承担更宏大的项目。

同时，我们也在开发新工具来处理目前生成的海量代码。随着代码生成成本的持续下降，我们需要新的方法来安全地将这些代码部署到生产环境中。

立即前往 cursor.com/agents 体验长时间运行智能体。

## 关联主题

- [[00-元语/Cursor]]
- [[00-元语/Agent]]
- [[00-元语/llm]]
- [[00-元语/workflow]]
- [[00-元语/cli]]
